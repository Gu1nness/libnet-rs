/* automatically generated by rust-bindgen */

extern crate libc;
pub use libc::FILE;
#[cfg(unix)] pub use libc::{sockaddr, timeval};

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: usize,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20usize],
}
pub type in_addr_t = u32;
#[repr(C)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
pub struct libnet_802_1q_hdr {
    #[doc = "< destination ethernet address"]
    pub vlan_dhost: [u8; 6usize],
    #[doc = "< source ethernet address"]
    pub vlan_shost: [u8; 6usize],
    #[doc = "< tag protocol ID"]
    pub vlan_tpi: u16,
    #[doc = "< priority | VLAN ID"]
    pub vlan_priority_c_vid: u16,
    #[doc = "< length or type (802.3 / Eth 2)"]
    pub vlan_len: u16,
}
#[repr(C)]
pub struct libnet_802_1x_hdr {
    #[doc = "< protocol version"]
    pub dot1x_version: u8,
    #[doc = "< frame type"]
    pub dot1x_type: u8,
    #[doc = "< total frame length"]
    pub dot1x_length: u16,
}
#[repr(C)]
pub struct libnet_802_2_hdr {
    pub llc_dsap: u8,
    pub llc_ssap: u8,
    pub llc_control: u8,
}
#[repr(C)]
pub struct libnet_802_2snap_hdr {
    pub snap_dsap: u8,
    pub snap_ssap: u8,
    pub snap_control: u8,
    pub snap_oui: [u8; 3usize],
    pub snap_type: u16,
}
#[repr(C)]
pub struct libnet_802_3_hdr {
    pub _802_3_dhost: [u8; 6usize],
    pub _802_3_shost: [u8; 6usize],
    pub _802_3_len: u16,
}
#[repr(C)]
pub struct libnet_arp_hdr {
    pub ar_hrd: u16,
    pub ar_pro: u16,
    pub ar_hln: u8,
    pub ar_pln: u8,
    pub ar_op: u16,
}
#[repr(C)]
pub struct libnet_bgp4_header_hdr {
    pub marker: [u8; 16usize],
    pub len: u16,
    pub type_: u8,
}
#[repr(C)]
pub struct libnet_bgp4_open_hdr {
    pub version: u8,
    pub src_as: u16,
    pub hold_time: u16,
    pub bgp_id: u32,
    pub opt_len: u8,
}
#[repr(C)]
pub struct libnet_bgp4_notification_hdr {
    pub err_code: u8,
    pub err_subcode: u8,
}
#[repr(C)]
pub struct libnet_cdp_hdr {
    pub cdp_version: u8,
    pub cdp_ttl: u8,
    pub cdp_sum: u16,
    pub cdp_type: u16,
    pub cdp_len: u16,
}
#[repr(C)]
pub struct libnet_cdp_value_hdr {
    pub cdp_type: u16,
    pub cdp_len: u16,
}
#[repr(C)]
pub struct libnet_dhcpv4_hdr {
    pub dhcp_opcode: u8,
    pub dhcp_htype: u8,
    pub dhcp_hlen: u8,
    pub dhcp_hopcount: u8,
    pub dhcp_xid: u32,
    pub dhcp_secs: u16,
    pub dhcp_flags: u16,
    pub dhcp_cip: u32,
    pub dhcp_yip: u32,
    pub dhcp_sip: u32,
    pub dhcp_gip: u32,
    pub dhcp_chaddr: [u8; 16usize],
    pub dhcp_sname: [libc::c_char; 64usize],
    pub dhcp_file: [libc::c_char; 128usize],
    pub dhcp_magic: u32,
}
#[repr(C)]
pub struct libnet_dnsv4_hdr {
    pub h_len: u16,
    pub id: u16,
    pub flags: u16,
    pub num_q: u16,
    pub num_answ_rr: u16,
    pub num_auth_rr: u16,
    pub num_addi_rr: u16,
}
#[repr(C)]
pub struct libnet_dnsv4udp_hdr {
    pub id: u16,
    pub flags: u16,
    pub num_q: u16,
    pub num_answ_rr: u16,
    pub num_auth_rr: u16,
    pub num_addi_rr: u16,
}
#[repr(C)]
pub struct libnet_ethernet_hdr {
    pub ether_dhost: [u8; 6usize],
    pub ether_shost: [u8; 6usize],
    pub ether_type: u16,
}
#[repr(C)]
pub struct libnet_ether_addr {
    pub ether_addr_octet: [u8; 6usize],
}
#[repr(C)]
pub struct libnet_fddi_hdr {
    pub fddi_frame_control: u8,
    pub fddi_dhost: [u8; 6usize],
    pub fddi_shost: [u8; 6usize],
    pub fddi_llc_dsap: u8,
    pub fddi_llc_ssap: u8,
    pub fddi_llc_control_field: u8,
    pub fddi_llc_org_code: [u8; 3usize],
    pub fddi_type: u8,
    pub fddi_type1: u8,
}
#[repr(C)]
pub struct libnet_fddi_addr {
    pub fddi_addr_octet: [u8; 6usize],
}
#[repr(C)]
pub struct libnet_gre_hdr {
    pub flags_ver: u16,
    pub type_: u16,
    pub _data: libnet_gre_hdr__bindgen_ty_1,
}
#[repr(C)]
pub struct libnet_gre_hdr__bindgen_ty_1 {
    pub _gre: __BindgenUnionField<libnet_gre_hdr__bindgen_ty_1__bindgen_ty_1>,
    pub _egre: __BindgenUnionField<libnet_gre_hdr__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 3usize],
}
#[repr(C)]
pub struct libnet_gre_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub sum: u16,
    pub offset: u16,
    pub key: u32,
    pub seq: u32,
}
#[repr(C)]
pub struct libnet_gre_hdr__bindgen_ty_1__bindgen_ty_2 {
    pub payload_s: u16,
    pub callID: u16,
    pub seq: u32,
    pub ack: u32,
}
#[repr(C)]
pub struct libnet_gre_sre_hdr {
    pub af: u16,
    pub sre_offset: u8,
    pub sre_length: u8,
    pub routing: *mut u8,
}
#[repr(C)]
pub struct libnet_ipv4_hdr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub ip_tos: u8,
    pub ip_len: u16,
    pub ip_id: u16,
    pub ip_off: u16,
    pub ip_ttl: u8,
    pub ip_p: u8,
    pub ip_sum: u16,
    pub ip_src: in_addr,
    pub ip_dst: in_addr,
}
impl libnet_ipv4_hdr {
    #[inline]
    pub fn ip_hl(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ip_hl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_v(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ip_v(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip_hl: u8, ip_v: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ip_hl: u8 = unsafe { ::std::mem::transmute(ip_hl) };
            ip_hl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ip_v: u8 = unsafe { ::std::mem::transmute(ip_v) };
            ip_v as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct libnet_in6_addr {
    pub __u6_addr: libnet_in6_addr__bindgen_ty_1,
}
#[repr(C)]
pub struct libnet_in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[u8; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[u16; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(C)]
pub struct libnet_ipv6_hdr {
    pub ip_flags: [u8; 4usize],
    pub ip_len: u16,
    pub ip_nh: u8,
    pub ip_hl: u8,
    pub ip_src: libnet_in6_addr,
    pub ip_dst: libnet_in6_addr,
}
#[repr(C)]
pub struct libnet_ipv6_frag_hdr {
    pub ip_nh: u8,
    pub ip_reserved: u8,
    pub ip_frag: u16,
    pub ip_id: u32,
}
#[repr(C)]
pub struct libnet_ipv6_routing_hdr {
    pub ip_nh: u8,
    pub ip_len: u8,
    pub ip_rtype: u8,
    pub ip_segments: u8,
}
#[repr(C)]
pub struct libnet_ipv6_destopts_hdr {
    pub ip_nh: u8,
    pub ip_len: u8,
}
#[repr(C)]
pub struct libnet_ipv6_hbhopts_hdr {
    pub ip_nh: u8,
    pub ip_len: u8,
}
#[repr(C)]
pub struct libnet_icmpv6_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_sum: u16,
    pub id: u16,
    pub seq: u16,
}
#[repr(C)]
pub struct libnet_icmpv6_unreach {
    pub unused: u32,
}
#[repr(C)]
pub struct libnet_icmpv6_echo {
    pub id: u16,
    pub seq: u16,
}
#[repr(C)]
pub struct libnet_icmpv6_ndp_nsol {
    pub reserved: u32,
    pub target_addr: libnet_in6_addr,
}
#[repr(C)]
pub struct libnet_icmpv6_ndp_nadv {
    pub flags: u32,
    pub target_addr: libnet_in6_addr,
}
#[repr(C)]
pub struct libnet_icmpv6_ndp_opt {
    pub type_: u8,
    pub len: u8,
}
#[repr(C)]
pub struct libnet_icmpv4_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_sum: u16,
    pub hun: libnet_icmpv4_hdr__bindgen_ty_1,
    pub dun: libnet_icmpv4_hdr__bindgen_ty_2,
}
#[repr(C)]
pub struct libnet_icmpv4_hdr__bindgen_ty_1 {
    pub echo: __BindgenUnionField<libnet_icmpv4_hdr__bindgen_ty_1__bindgen_ty_1>,
    pub gateway: __BindgenUnionField<u32>,
    pub frag: __BindgenUnionField<libnet_icmpv4_hdr__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
pub struct libnet_icmpv4_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub id: u16,
    pub seq: u16,
}
#[repr(C)]
pub struct libnet_icmpv4_hdr__bindgen_ty_1__bindgen_ty_2 {
    pub pad: u16,
    pub mtu: u16,
}
#[repr(C)]
pub struct libnet_icmpv4_hdr__bindgen_ty_2 {
    pub ts: __BindgenUnionField<libnet_icmpv4_hdr__bindgen_ty_2__bindgen_ty_1>,
    pub ip: __BindgenUnionField<libnet_icmpv4_hdr__bindgen_ty_2__bindgen_ty_2>,
    pub mask: __BindgenUnionField<u32>,
    pub data: __BindgenUnionField<[i8; 1usize]>,
    pub bindgen_union_field: [u32; 5usize],
}
#[repr(C)]
pub struct libnet_icmpv4_hdr__bindgen_ty_2__bindgen_ty_1 {
    pub its_otime: u32,
    pub its_rtime: u32,
    pub its_ttime: u32,
}
#[repr(C)]
pub struct libnet_icmpv4_hdr__bindgen_ty_2__bindgen_ty_2 {
    pub idi_ip: libnet_ipv4_hdr,
}
#[repr(C)]
pub struct libnet_igmp_hdr {
    pub igmp_type: u8,
    pub igmp_code: u8,
    pub igmp_sum: u16,
    pub igmp_group: in_addr,
}
#[repr(C)]
pub struct libnet_esp_hdr {
    pub esp_spi: u32,
    pub esp_seq: u32,
    pub esp_iv: u32,
}
#[repr(C)]
pub struct libnet_esp_ftr {
    pub esp_pad_len: u8,
    pub esp_nh: u8,
    pub esp_auth: *mut i8,
}
#[repr(C)]
pub struct libnet_ah_hdr {
    pub ah_nh: u8,
    pub ah_len: u8,
    pub ah_res: u16,
    pub ah_spi: u32,
    pub ah_seq: u32,
    pub ah_auth: u32,
}
#[repr(C)]
pub struct libnet_isl_hdr {
    pub isl_dhost: [u8; 5usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub isl_shost: [u8; 6usize],
    pub isl_len: u16,
    pub isl_snap: [u8; 6usize],
    pub isl_vid: u16,
    pub isl_index: u16,
    pub isl_reserved: u16,
}
impl libnet_isl_hdr {
    #[inline]
    pub fn isl_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_isl_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn isl_user(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_isl_user(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isl_type: u8, isl_user: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let isl_type: u8 = unsafe { ::std::mem::transmute(isl_type) };
            isl_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let isl_user: u8 = unsafe { ::std::mem::transmute(isl_user) };
            isl_user as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct libnet_mpls_hdr {
    pub mpls_les: u32,
}
#[repr(C)]
pub struct libnet_ntp_hdr_l_fp {
    pub integer: u32,
    pub fraction: u32,
}
#[repr(C)]
pub struct libnet_ntp_hdr_s_fp {
    pub integer: u16,
    pub fraction: u16,
}
#[repr(C)]
pub struct libnet_ntp_hdr {
    pub ntp_li_vn_mode: u8,
    pub ntp_stratum: u8,
    pub ntp_poll: u8,
    pub ntp_precision: u8,
    pub ntp_delay: libnet_ntp_hdr_s_fp,
    pub ntp_dispersion: libnet_ntp_hdr_s_fp,
    pub ntp_reference_id: u32,
    pub ntp_ref_ts: libnet_ntp_hdr_l_fp,
    pub ntp_orig_ts: libnet_ntp_hdr_l_fp,
    pub ntp_rec_ts: libnet_ntp_hdr_l_fp,
    pub ntp_xmt_ts: libnet_ntp_hdr_l_fp,
}
#[repr(C)]
pub struct libnet_ospf_hdr {
    pub ospf_v: u8,
    pub ospf_type: u8,
    pub ospf_len: u16,
    pub ospf_rtr_id: in_addr,
    pub ospf_area_id: in_addr,
    pub ospf_sum: u16,
    pub ospf_auth_type: u16,
}
#[repr(C)]
pub struct libnet_auth_hdr {
    pub ospf_auth_null: u16,
    pub ospf_auth_keyid: u8,
    pub ospf_auth_len: u8,
    pub ospf_auth_seq: u32,
}
#[repr(C)]
pub struct libnet_ospf_hello_hdr {
    pub hello_nmask: in_addr,
    pub hello_intrvl: u16,
    pub hello_opts: u8,
    pub hello_rtr_pri: u8,
    pub hello_dead_intvl: u32,
    pub hello_des_rtr: in_addr,
    pub hello_bkup_rtr: in_addr,
    pub hello_nbr: in_addr,
}
#[repr(C)]
pub struct libnet_dbd_hdr {
    pub dbd_mtu_len: u16,
    pub dbd_opts: u8,
    pub dbd_type: u8,
    pub dbd_seq: u32,
}
#[repr(C)]
pub struct libnet_lsr_hdr {
    pub lsr_type: u32,
    pub lsr_lsid: u32,
    pub lsr_adrtr: in_addr,
}
#[repr(C)]
pub struct libnet_lsu_hdr {
    pub lsu_num: u32,
}
#[repr(C)]
pub struct libnet_lsa_hdr {
    pub lsa_age: u16,
    pub lsa_opts: u8,
    pub lsa_type: u8,
    pub lsa_id: u32,
    pub lsa_adv: in_addr,
    pub lsa_seq: u32,
    pub lsa_sum: u16,
    pub lsa_len: u16,
}
#[repr(C)]
pub struct libnet_rtr_lsa_hdr {
    pub rtr_flags: u16,
    pub rtr_num: u16,
    pub rtr_link_id: u32,
    pub rtr_link_data: u32,
    pub rtr_type: u8,
    pub rtr_tos_num: u8,
    pub rtr_metric: u16,
}
#[repr(C)]
pub struct libnet_net_lsa_hdr {
    pub net_nmask: in_addr,
    pub net_rtr_id: u32,
}
#[repr(C)]
pub struct libnet_sum_lsa_hdr {
    pub sum_nmask: in_addr,
    pub sum_metric: u32,
    pub sum_tos_metric: u32,
}
#[repr(C)]
pub struct libnet_as_lsa_hdr {
    pub as_nmask: in_addr,
    pub as_metric: u32,
    pub as_fwd_addr: in_addr,
    pub as_rte_tag: u32,
}
#[repr(C)]
pub struct libnet_rip_hdr {
    pub rip_cmd: u8,
    pub rip_ver: u8,
    pub rip_rd: u16,
    pub rip_af: u16,
    pub rip_rt: u16,
    pub rip_addr: u32,
    pub rip_mask: u32,
    pub rip_next_hop: u32,
    pub rip_metric: u32,
}
#[repr(C)]
pub struct libnet_rpc_opaque_auth {
    pub rpc_auth_flavor: u32,
    pub rpc_auth_length: u32,
}
#[repr(C)]
pub struct libnet_rpc_call {
    pub rpc_rpcvers: u32,
    pub rpc_prognum: u32,
    pub rpc_vers: u32,
    pub rpc_procedure: u32,
    pub rpc_credentials: libnet_rpc_opaque_auth,
    pub rpc_verifier: libnet_rpc_opaque_auth,
}
#[repr(C)]
pub struct libnet_rpc_call_hdr {
    pub rpc_xid: u32,
    pub rpc_type: u32,
    pub rpc_call: libnet_rpc_call,
}
#[repr(C)]
pub struct libnet_rpc_call_tcp_hdr {
    pub rpc_record_marking: u32,
    pub rpc_common: libnet_rpc_call_hdr,
}
#[repr(C)]
pub struct libnet_stp_conf_hdr {
    pub stp_id: u16,
    pub stp_version: u8,
    pub stp_bpdu_type: u8,
    pub stp_flags: u8,
    pub stp_rootid: [u8; 8usize],
    pub stp_rootpc: u32,
    pub stp_bridgeid: [u8; 8usize],
    pub stp_portid: u16,
    pub stp_mage: u16,
    pub stp_maxage: u16,
    pub stp_hellot: u16,
    pub stp_fdelay: u16,
}
#[repr(C)]
pub struct libnet_stp_tcn_hdr {
    pub stp_id: u16,
    pub stp_version: u8,
    pub stp_bpdu_type: u8,
}
#[repr(C)]
pub struct libnet_tcp_hdr {
    pub th_sport: u16,
    pub th_dport: u16,
    pub th_seq: u32,
    pub th_ack: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub th_flags: u8,
    pub th_win: u16,
    pub th_sum: u16,
    pub th_urp: u16,
}
impl libnet_tcp_hdr {
    #[inline]
    pub fn th_x2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u8, th_off: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u8 = unsafe { ::std::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u8 = unsafe { ::std::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct libnet_token_ring_hdr {
    pub token_ring_access_control: u8,
    pub token_ring_frame_control: u8,
    pub token_ring_dhost: [u8; 6usize],
    pub token_ring_shost: [u8; 6usize],
    pub token_ring_llc_dsap: u8,
    pub token_ring_llc_ssap: u8,
    pub token_ring_llc_control_field: u8,
    pub token_ring_llc_org_code: [u8; 3usize],
    pub token_ring_type: u16,
}
#[repr(C)]
pub struct libnet_token_ring_addr {
    pub token_ring_addr_octet: [u8; 6usize],
}
#[repr(C)]
pub struct libnet_udp_hdr {
    pub uh_sport: u16,
    pub uh_dport: u16,
    pub uh_ulen: u16,
    pub uh_sum: u16,
}
#[repr(C)]
pub struct libnet_sebek_hdr {
    pub magic: u32,
    pub version: u16,
    pub type_: u16,
    pub counter: u32,
    pub time_sec: u32,
    pub time_usec: u32,
    pub pid: u32,
    pub uid: u32,
    pub fd: u32,
    pub cmd: [u8; 12usize],
    pub length: u32,
}
#[repr(C)]
pub struct libnet_vrrp_hdr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub vrrp_vrouter_id: u8,
    pub vrrp_priority: u8,
    pub vrrp_ip_count: u8,
    pub vrrp_auth_type: u8,
    pub vrrp_advert_int: u8,
    pub vrrp_sum: u16,
}
impl libnet_vrrp_hdr {
    #[inline]
    pub fn vrrp_v(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_vrrp_v(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn vrrp_t(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_vrrp_t(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(vrrp_v: u8, vrrp_t: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let vrrp_v: u8 = unsafe { ::std::mem::transmute(vrrp_v) };
            vrrp_v as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let vrrp_t: u8 = unsafe { ::std::mem::transmute(vrrp_t) };
            vrrp_t as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct libnet_hsrp_hdr {
    pub version: u8,
    pub opcode: u8,
    pub state: u8,
    pub hello_time: u8,
    pub hold_time: u8,
    pub priority: u8,
    pub group: u8,
    pub reserved: u8,
    pub authdata: [u8; 8usize],
    pub virtual_ip: u32,
}
pub type libnet_plist_t = libnet_port_list_chain;
#[repr(C)]
pub struct libnet_port_list_chain {
    pub node: u16,
    pub bport: u16,
    pub eport: u16,
    pub id: u8,
    pub next: *mut libnet_plist_t,
}
#[repr(C)]
pub struct libnet_stats {
    pub packets_sent: u64,
    pub packet_errors: u64,
    pub bytes_written: u64,
}
pub type libnet_ptag_t = i32;
#[repr(C)]
pub struct libnet_protocol_block {
    pub buf: *mut u8,
    pub b_len: u32,
    pub h_len: u16,
    pub copied: u32,
    pub type_: u8,
    pub flags: u8,
    pub ptag: libnet_ptag_t,
    pub next: *mut libnet_protocol_block,
    pub prev: *mut libnet_protocol_block,
}
pub type libnet_pblock_t = libnet_protocol_block;
#[repr(C)]
pub struct libnet_context {
    pub fd: libc::c_int,
    pub injection_type: libc::c_int,
    pub protocol_blocks: *mut libnet_pblock_t,
    pub pblock_end: *mut libnet_pblock_t,
    pub n_pblocks: u32,
    pub link_type: libc::c_int,
    pub link_offset: libc::c_int,
    pub aligner: libc::c_int,
    pub device: *mut libc::c_char,
    pub stats: libnet_stats,
    pub ptag_state: libnet_ptag_t,
    pub label: [libc::c_char; 64usize],
    pub err_buf: [libc::c_char; 256usize],
    pub total_size: u32,
}
pub type libnet_t = libnet_context;
pub type libnet_cq_t = _libnet_context_queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libnet_context_queue {
    pub context: *mut libnet_t,
    pub next: *mut libnet_cq_t,
    pub prev: *mut libnet_cq_t,
}
#[repr(C)]
pub struct _libnet_context_queue_descriptor {
    pub node: u32,
    pub cq_lock: u32,
    pub current: *mut libnet_cq_t,
}
pub type libnet_cqd_t = _libnet_context_queue_descriptor;
pub type oid = u32;
extern "C" {
    pub fn libnet_build_asn1_int(
        arg1: *mut u8,
        arg2: *mut libc::c_int,
        arg3: u8,
        arg4: *mut i32,
        arg5: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn libnet_build_asn1_uint(
        arg1: *mut u8,
        arg2: *mut libc::c_int,
        arg3: u8,
        arg4: *mut u32,
        arg5: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn libnet_build_asn1_string(
        arg1: *mut u8,
        arg2: *mut libc::c_int,
        arg3: u8,
        arg4: *mut u8,
        arg5: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn libnet_build_asn1_header(
        arg1: *mut u8,
        arg2: *mut libc::c_int,
        arg3: u8,
        arg4: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn libnet_build_asn1_length(
        arg1: *mut u8,
        arg2: *mut libc::c_int,
        arg3: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn libnet_build_asn1_sequence(
        arg1: *mut u8,
        arg2: *mut libc::c_int,
        arg3: u8,
        arg4: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn libnet_build_asn1_objid(
        arg1: *mut u8,
        arg2: *mut libc::c_int,
        arg3: u8,
        arg4: *mut oid,
        arg5: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn libnet_build_asn1_null(arg1: *mut u8, arg2: *mut libc::c_int, arg3: u8) -> *mut u8;
}
extern "C" {
    pub fn libnet_build_asn1_bitstring(
        arg1: *mut u8,
        arg2: *mut libc::c_int,
        arg3: u8,
        arg4: *mut u8,
        arg5: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Creates the libnet environment. It initializes the library and returns a"]
    #[doc = " libnet context. If the injection_type is LIBNET_LINK or LIBNET_LINK_ADV, the"]
    #[doc = " function initializes the injection primitives for the link-layer interface"]
    #[doc = " enabling the application programmer to build packets starting at the"]
    #[doc = " data-link layer (which also provides more granular control over the IP"]
    #[doc = " layer). If libnet uses the link-layer and the device argument is non-NULL,"]
    #[doc = " the function attempts to use the specified network device for packet"]
    #[doc = " injection. This is either a canonical string that references the device"]
    #[doc = " (such as \"eth0\" for a 100MB Ethernet card on Linux or \"fxp0\" for a 100MB"]
    #[doc = " Ethernet card on OpenBSD) or the dots and decimals representation of the"]
    #[doc = " device\'s IP address (192.168.0.1). If device is NULL, libnet attempts to"]
    #[doc = " find a suitable device to use. If the injection_type is LIBNET_RAW4 or"]
    #[doc = " LIBNET_RAW4_ADV, the function initializes the injection primitives for the"]
    #[doc = " IPv4 raw socket interface. The final argument, err_buf, should be a buffer"]
    #[doc = " of size LIBNET_ERRBUF_SIZE and holds an error message if the function fails."]
    #[doc = " This function requires root privileges to execute successfully. Upon"]
    #[doc = " success, the function returns a valid libnet context for use in later"]
    #[doc = " function calls; upon failure, the function returns NULL."]
    #[doc = " @param injection_type packet injection type (LIBNET_LINK, LIBNET_LINK_ADV, LIBNET_RAW4, LIBNET_RAW4_ADV, LIBNET_RAW6, LIBNET_RAW6_ADV)"]
    #[doc = " @param device the interface to use (NULL and libnet will choose one)"]
    #[doc = " @param err_buf will contain an error message on failure"]
    #[doc = " @return libnet context ready for use or NULL on error."]
    pub fn libnet_init(
        injection_type: libc::c_int,
        device: *const libc::c_char,
        err_buf: *mut libc::c_char,
    ) -> *mut libnet_t;
}
extern "C" {
    #[doc = " Shuts down the libnet session referenced by l. It closes the network"]
    #[doc = " interface and frees all internal memory structures associated with l."]
    #[doc = " @param l pointer to a libnet context"]
    pub fn libnet_destroy(l: *mut libnet_t);
}
extern "C" {
    #[doc = " Clears the current packet referenced and frees all pblocks. Should be"]
    #[doc = " called when the programmer want to send a completely new packet of"]
    #[doc = " a different type using the same context."]
    #[doc = " @param l pointer to a libnet context"]
    pub fn libnet_clear_packet(l: *mut libnet_t);
}
extern "C" {
    #[doc = " Fills in a libnet_stats structure with packet injection statistics"]
    #[doc = " (packets written, bytes written, packet sending errors)."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ls pointer to a libnet statistics structure"]
    pub fn libnet_stats(l: *mut libnet_t, ls: *mut libnet_stats);
}
extern "C" {
    #[doc = " Returns the FILENO of the file descriptor used for packet injection."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return the file number of the file descriptor used for packet injection"]
    pub fn libnet_getfd(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the canonical name of the device used for packet injection."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return the canonical name of the device used for packet injection. Note"]
    #[doc = " it can be NULL without being an error."]
    pub fn libnet_getdevice(l: *mut libnet_t) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Returns the pblock buffer contents for the specified ptag; a"]
    #[doc = " subsequent call to libnet_getpbuf_size() should be made to determine the"]
    #[doc = " size of the buffer."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag the ptag reference number"]
    #[doc = " @return a pointer to the pblock buffer or NULL on error"]
    pub fn libnet_getpbuf(l: *mut libnet_t, ptag: libnet_ptag_t) -> *mut u8;
}
extern "C" {
    #[doc = " Returns the pblock buffer size for the specified ptag; a"]
    #[doc = " previous call to libnet_getpbuf() should be made to pull the actual buffer"]
    #[doc = " contents."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag the ptag reference number"]
    #[doc = " @return the size of the pblock buffer"]
    pub fn libnet_getpbuf_size(l: *mut libnet_t, ptag: libnet_ptag_t) -> u32;
}
extern "C" {
    #[doc = " Returns the last error set inside of the referenced libnet context. This"]
    #[doc = " function should be called anytime a function fails or an error condition"]
    #[doc = " is detected inside of libnet."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return an error string or NULL if no error has occured"]
    pub fn libnet_geterror(l: *mut libnet_t) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Returns the sum of the size of all of the pblocks inside of l (this should"]
    #[doc = " be the resuling packet size)."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return the size of the packet in l"]
    pub fn libnet_getpacket_size(l: *mut libnet_t) -> u32;
}
extern "C" {
    #[doc = " Seeds the psuedo-random number generator."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_seed_prand(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Generates an unsigned psuedo-random value within the range specified by"]
    #[doc = " mod."]
    #[doc = " LIBNET_PR2    0 - 1"]
    #[doc = " LIBNET_PR8    0 - 255"]
    #[doc = " LIBNET_PR16   0 - 32767"]
    #[doc = " LIBNET_PRu16  0 - 65535"]
    #[doc = " LIBNET_PR32   0 - 2147483647"]
    #[doc = " LIBNET_PRu32  0 - 4294967295"]
    #[doc = ""]
    #[doc = " @param mod one the of LIBNET_PR* constants"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_get_prand(mod_: libc::c_int) -> u32;
}
extern "C" {
    #[doc = " If a given protocol header is built with the checksum field set to \"0\", by"]
    #[doc = " default libnet will calculate the header checksum prior to injection. If the"]
    #[doc = " header is set to any other value, by default libnet will not calculate the"]
    #[doc = " header checksum. To over-ride this behavior, use libnet_toggle_checksum()."]
    #[doc = " Switches auto-checksumming on or off for the specified ptag. If mode is set"]
    #[doc = " to LIBNET_ON, libnet will mark the specificed ptag to calculate a checksum"]
    #[doc = " for the ptag prior to injection. This assumes that the ptag refers to a"]
    #[doc = " protocol that has a checksum field. If mode is set to LIBNET_OFF, libnet"]
    #[doc = " will clear the checksum flag and no checksum will be computed prior to"]
    #[doc = " injection. This assumes that the programmer will assign a value (zero or"]
    #[doc = " otherwise) to the checksum field.  Often times this is useful if a"]
    #[doc = " precomputed checksum or some other predefined value is going to be used."]
    #[doc = " Note that when libnet is initialized with LIBNET_RAW4, the IPv4 header"]
    #[doc = " checksum will always be computed by the kernel prior to injection,"]
    #[doc = " regardless of what the programmer sets."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag the ptag reference number"]
    #[doc = " @param mode LIBNET_ON or LIBNET_OFF"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_toggle_checksum(
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
        mode: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Takes a network byte ordered IPv4 address and returns a pointer to either a"]
    #[doc = " canonical DNS name (if it has one) or a string of dotted decimals. This may"]
    #[doc = " incur a DNS lookup if the hostname and mode is set to LIBNET_RESOLVE. If"]
    #[doc = " mode is set to LIBNET_DONT_RESOLVE, no DNS lookup will be performed and"]
    #[doc = " the function will return a pointer to a dotted decimal string. The function"]
    #[doc = " cannot fail -- if no canonical name exists, it will fall back on returning"]
    #[doc = " a dotted decimal string. This function is non-reentrant."]
    #[doc = " @param in network byte ordered IPv4 address"]
    #[doc = " @param use_name LIBNET_RESOLVE or LIBNET_DONT_RESOLVE"]
    #[doc = " @return a pointer to presentation format string"]
    pub fn libnet_addr2name4(in_: u32, use_name: u8) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Takes a dotted decimal string or a canonical DNS name and returns a"]
    #[doc = " network byte ordered IPv4 address. This may incur a DNS lookup if mode is"]
    #[doc = " set to LIBNET_RESOLVE and host_name refers to a canonical DNS name. If mode"]
    #[doc = " is set to LIBNET_DONT_RESOLVE no DNS lookup will occur. The function can"]
    #[doc = " fail if DNS lookup fails or if mode is set to LIBNET_DONT_RESOLVE and"]
    #[doc = " host_name refers to a canonical DNS name."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param host_name pointer to a string containing a presentation format host"]
    #[doc = " name"]
    #[doc = " @param use_name LIBNET_RESOLVE or LIBNET_DONT_RESOLVE"]
    #[doc = " @return address in network byte order"]
    #[doc = " @retval -1 (2^32 - 1) on error"]
    pub fn libnet_name2addr4(l: *mut libnet_t, host_name: *const libc::c_char, use_name: u8)
        -> u32;
}
extern "C" {
    #[doc = " Check a libnet_in6_addr structure for identity with in6addr_error."]
    #[doc = " @param addr address to check"]
    #[doc = " @retval 1 if addr is in6addr_error"]
    #[doc = " @retval 0 if it is not"]
    pub fn libnet_in6_is_error(addr: libnet_in6_addr) -> libc::c_int;
}
extern "C" {
    #[doc = " Takes a dotted decimal string or a canonical DNS name and returns a"]
    #[doc = " network byte ordered IPv6 address. This may incur a DNS lookup if mode is"]
    #[doc = " set to LIBNET_RESOLVE and host_name refers to a canonical DNS name. If mode"]
    #[doc = " is set to LIBNET_DONT_RESOLVE no DNS lookup will occur. The function can"]
    #[doc = " fail if DNS lookup fails or if mode is set to LIBNET_DONT_RESOLVE and"]
    #[doc = " host_name refers to a canonical DNS name."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param host_name pointer to a string containing a presentation format host"]
    #[doc = " name"]
    #[doc = " @param use_name LIBNET_RESOLVE or LIBNET_DONT_RESOLVE"]
    #[doc = " @return network byte ordered IPv6 address structure"]
    pub fn libnet_name2addr6(
        l: *mut libnet_t,
        host_name: *const libc::c_char,
        use_name: u8,
    ) -> libnet_in6_addr;
}
extern "C" {
    #[doc = " Should document this baby right here."]
    pub fn libnet_addr2name6_r(
        addr: libnet_in6_addr,
        use_name: u8,
        host_name: *mut libc::c_char,
        host_name_len: libc::c_int,
    );
}
extern "C" {
    #[doc = " Creates a new port list. Port list chains are useful for TCP and UDP-based"]
    #[doc = " applications that need to send packets to a range of ports (contiguous or"]
    #[doc = " otherwise). The port list chain, which token_list points to, should contain"]
    #[doc = " a series of int8_tacters from the following list: \"0123456789,-\" of the"]
    #[doc = " general format \"x - y, z\", where \"xyz\" are port numbers between 0 and"]
    #[doc = " 65,535. plist points to the front of the port list chain list for use in"]
    #[doc = " further libnet_plist_chain() functions. Upon success, the function returns"]
    #[doc = " 1. Upon failure, the function returns -1 and libnet_geterror() can tell you"]
    #[doc = " why."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param plist if successful, will refer to the portlist, if not, NULL"]
    #[doc = " @param token_list string containing the port list primitive"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_plist_chain_new(
        l: *mut libnet_t,
        plist: *mut *mut libnet_plist_t,
        token_list: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the next port list chain pair from the port list chain plist. bport"]
    #[doc = " and eport contain the starting port number and ending port number,"]
    #[doc = " respectively. Upon success, the function returns 1 and fills in the port"]
    #[doc = " variables; however, if the list is empty, the function returns 0 and sets"]
    #[doc = " both port variables to 0. Upon failure, the function returns -1."]
    #[doc = " @param plist previously created portlist"]
    #[doc = " @param bport will contain the beginning port number or 0"]
    #[doc = " @param eport will contain the ending port number or 0"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval 0 if empty"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_plist_chain_next_pair(
        plist: *mut libnet_plist_t,
        bport: *mut u16,
        eport: *mut u16,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Runs through the port list and prints the contents of the port list chain"]
    #[doc = " list to stdout."]
    #[doc = " @param plist previously created portlist"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_plist_chain_dump(plist: *mut libnet_plist_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Runs through the port list and prints the contents of the port list chain"]
    #[doc = " list to string. This function uses strdup and is not re-entrant.  It also"]
    #[doc = " has a memory leak and should not really be used."]
    #[doc = " @param plist previously created portlist"]
    #[doc = " @return a printable string containing the port list contents on success or NULL on error"]
    pub fn libnet_plist_chain_dump_string(plist: *mut libnet_plist_t) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Frees all memory associated with port list chain."]
    #[doc = " @param plist previously created portlist"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_plist_chain_free(plist: *mut libnet_plist_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Builds an IEEE 802.1q VLAN tagging header. Depending on the value of"]
    #[doc = " len_proto, the function wraps the 802.1q header inside either an IEEE 802.3"]
    #[doc = " header or an RFC 894 Ethernet II (DIX) header (both resulting in an 18-byte"]
    #[doc = " frame). If len is 1500 or less, most receiving protocol stacks parse the"]
    #[doc = " frame as an IEEE 802.3 encapsulated frame. If len is one of the Ethernet type"]
    #[doc = " values, most protocol stacks parse the frame as an RFC 894 Ethernet II"]
    #[doc = " encapsulated frame. Note the length value is calculated without the 802.1q"]
    #[doc = " header of 18 bytes."]
    #[doc = " @param dst pointer to a six byte source ethernet address"]
    #[doc = " @param src pointer to a six byte destination ethernet address"]
    #[doc = " @param tpi tag protocol identifier"]
    #[doc = " @param priority priority"]
    #[doc = " @param cfi canonical format indicator"]
    #[doc = " @param vlan_id vlan identifier"]
    #[doc = " @param len_proto length (802.3) protocol (Ethernet II)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_802_1q(
        dst: *const u8,
        src: *const u8,
        tpi: u16,
        priority: u8,
        cfi: u8,
        vlan_id: u16,
        len_proto: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IEEE 802.1x extended authentication protocol header."]
    #[doc = " @param eap_ver the EAP version"]
    #[doc = " @param eap_type the EAP type"]
    #[doc = " @param length frame length"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_802_1x(
        eap_ver: u8,
        eap_type: u8,
        length: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IEEE 802.2 LLC header."]
    #[doc = " @param dsap destination service access point"]
    #[doc = " @param ssap source service access point"]
    #[doc = " @param control control field"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_802_2(
        dsap: u8,
        ssap: u8,
        control: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IEEE 802.2 LLC SNAP header."]
    #[doc = " @param dsap destination service access point"]
    #[doc = " @param ssap source service access point"]
    #[doc = " @param control control field"]
    #[doc = " @param oui Organizationally Unique Identifier"]
    #[doc = " @param type upper layer protocol"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_802_2snap(
        dsap: u8,
        ssap: u8,
        control: u8,
        oui: *mut u8,
        type_: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IEEE 802.3 header. The 802.3 header is almost identical to the"]
    #[doc = " RFC 894 Ethernet II header, the exception being that the field immediately"]
    #[doc = " following the source address holds the frame\'s length (as opposed to the"]
    #[doc = " layer 3 protocol). You should only use this function when libnet is"]
    #[doc = " initialized with the LIBNET_LINK interface."]
    #[doc = " @param dst destination ethernet address"]
    #[doc = " @param src source ethernet address"]
    #[doc = " @param len frame length sans header"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_802_3(
        dst: *const u8,
        src: *const u8,
        len: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an Ethernet header. The RFC 894 Ethernet II header is almost"]
    #[doc = " identical to the IEEE 802.3 header, with the exception that the field"]
    #[doc = " immediately following the source address holds the layer 3 protocol (as"]
    #[doc = " opposed to frame\'s length). You should only use this function when"]
    #[doc = " libnet is initialized with the LIBNET_LINK interface."]
    #[doc = " @param dst destination ethernet address"]
    #[doc = " @param src source ethernet address"]
    #[doc = " @param type upper layer protocol type"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ethernet(
        dst: *const u8,
        src: *const u8,
        type_: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Autobuilds an Ethernet header. The RFC 894 Ethernet II header is almost"]
    #[doc = " identical to the IEEE 802.3 header, with the exception that the field"]
    #[doc = " immediately following the source address holds the layer 3 protocol (as"]
    #[doc = " opposed to frame\'s length). You should only use this function when"]
    #[doc = " libnet is initialized with the LIBNET_LINK interface."]
    #[doc = " @param dst destination ethernet address"]
    #[doc = " @param type upper layer protocol type"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_autobuild_ethernet(dst: *const u8, type_: u16, l: *mut libnet_t)
        -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a Fiber Distributed Data Interface (FDDI) header."]
    #[doc = " @param fc class format and priority"]
    #[doc = " @param dst destination fddi address"]
    #[doc = " @param src source fddi address"]
    #[doc = " @param dsap destination service access point"]
    #[doc = " @param ssap source service access point"]
    #[doc = " @param cf cf"]
    #[doc = " @param oui 3 byte IEEE organizational code"]
    #[doc = " @param type upper layer protocol"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_fddi(
        fc: u8,
        dst: *const u8,
        src: *const u8,
        dsap: u8,
        ssap: u8,
        cf: u8,
        oui: *const u8,
        type_: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Autobuilds a Fiber Distributed Data Interface (FDDI) header."]
    #[doc = " @param fc class format and priority"]
    #[doc = " @param dst destination fddi address"]
    #[doc = " @param dsap destination service access point"]
    #[doc = " @param ssap source service access point"]
    #[doc = " @param cf cf"]
    #[doc = " @param oui IEEE organizational code"]
    #[doc = " @param type upper layer protocol"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_autobuild_fddi(
        fc: u8,
        dst: *const u8,
        dsap: u8,
        ssap: u8,
        cf: u8,
        oui: *const u8,
        type_: u16,
        l: *mut libnet_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an Address Resolution Protocol (ARP) header.  Depending on the op"]
    #[doc = " value, the function builds one of several different types of RFC 826 or"]
    #[doc = " RFC 903 RARP packets."]
    #[doc = " @param hrd hardware address format"]
    #[doc = " @param pro protocol address format"]
    #[doc = " @param hln hardware address length"]
    #[doc = " @param pln protocol address length"]
    #[doc = " @param op ARP operation type"]
    #[doc = " @param sha sender\'s hardware address"]
    #[doc = " @param spa sender\'s protocol address"]
    #[doc = " @param tha target hardware address"]
    #[doc = " @param tpa target protocol address"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_arp(
        hrd: u16,
        pro: u16,
        hln: u8,
        pln: u8,
        op: u16,
        sha: *const u8,
        spa: *const u8,
        tha: *const u8,
        tpa: *const u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Autouilds an Address Resolution Protocol (ARP) header.  Depending on the op"]
    #[doc = " value, the function builds one of several different types of RFC 826 or"]
    #[doc = " RFC 903 RARP packets."]
    #[doc = " @param op ARP operation type"]
    #[doc = " @param sha sender\'s hardware address"]
    #[doc = " @param spa sender\'s protocol address"]
    #[doc = " @param tha target hardware address"]
    #[doc = " @param tpa target protocol address"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_autobuild_arp(
        op: u16,
        sha: *const u8,
        spa: *const u8,
        tha: *const u8,
        tpa: *const u8,
        l: *mut libnet_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 793 Transmission Control Protocol (TCP) header."]
    #[doc = " @param sp source port"]
    #[doc = " @param dp destination port"]
    #[doc = " @param seq sequence number"]
    #[doc = " @param ack acknowledgement number"]
    #[doc = " @param control control flags"]
    #[doc = " @param win window size"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param urg urgent pointer"]
    #[doc = " @param len total length of the TCP packet (for checksum calculation)"]
    #[doc = " @param payload"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_tcp(
        sp: u16,
        dp: u16,
        seq: u32,
        ack: u32,
        control: u8,
        win: u16,
        sum: u16,
        urg: u16,
        len: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 793 Transmission Control Protocol (TCP) options header."]
    #[doc = " The function expects options to be a valid TCP options string of size"]
    #[doc = " options_s, which is no larger than 40 bytes (the maximum size of an"]
    #[doc = " options string). The function checks to ensure that the packet consists of"]
    #[doc = " a TCP header preceded by an IPv4 header, and that the addition of the"]
    #[doc = " options string would not result in a packet larger than 65,535 bytes"]
    #[doc = " (IPMAXPACKET). The function counts up the number of 32-bit words in the"]
    #[doc = " options string and adjusts the TCP header length value as necessary."]
    #[doc = " @param options byte string of TCP options"]
    #[doc = " @param options_s length of options string"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_tcp_options(
        options: *const u8,
        options_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 768 User Datagram Protocol (UDP) header."]
    #[doc = " @param sp source port"]
    #[doc = " @param dp destination port"]
    #[doc = " @param len total length of the UDP packet"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_udp(
        sp: u16,
        dp: u16,
        len: u16,
        sum: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a Cisco Discovery Protocol (CDP) header. Cisco Systems designed CDP"]
    #[doc = " to aid in the network management of adjacent Cisco devices. The CDP protocol"]
    #[doc = " specifies data by using a type/length/value (TLV) setup. The first TLV can"]
    #[doc = " specified by using the functions type, length, and value arguments. To"]
    #[doc = " specify additional TLVs, the programmer could either use the payload"]
    #[doc = " interface or libnet_build_data() to construct them."]
    #[doc = " @param version CDP version"]
    #[doc = " @param ttl time to live (time information should be cached by recipient)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param type type of data contained in value"]
    #[doc = " @param value_s length of value argument"]
    #[doc = " @param value the CDP information string"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_cdp(
        version: u8,
        ttl: u8,
        sum: u16,
        type_: u16,
        value_s: u16,
        value: *const u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP)"]
    #[doc = " echo request/reply header"]
    #[doc = " @param type type of ICMP packet (should be ICMP_ECHOREPLY or ICMP_ECHO)"]
    #[doc = " @param code code of ICMP packet (should be 0)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param id identification number"]
    #[doc = " @param seq packet sequence number"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv4_echo(
        type_: u8,
        code: u8,
        sum: u16,
        id: u16,
        seq: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP)"]
    #[doc = " IP netmask request/reply header."]
    #[doc = " @param type type of ICMP packet (should be ICMP_MASKREQ or ICMP_MASKREPLY)"]
    #[doc = " @param code code of ICMP packet (should be 0)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param id identification number"]
    #[doc = " @param seq packet sequence number"]
    #[doc = " @param mask subnet mask"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv4_mask(
        type_: u8,
        code: u8,
        sum: u16,
        id: u16,
        seq: u16,
        mask: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP)"]
    #[doc = " unreachable header. The IP header that caused the error message should be"]
    #[doc = " built by a previous call to libnet_build_ipv4()."]
    #[doc = " @param type type of ICMP packet (should be ICMP_UNREACH)"]
    #[doc = " @param code code of ICMP packet (should be one of the 16 unreachable codes)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv4_unreach(
        type_: u8,
        code: u8,
        sum: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 4 RFC 792 Internet Message Control Protocol (ICMP)"]
    #[doc = " redirect header.  The IP header that caused the error message should be"]
    #[doc = " built by a previous call to libnet_build_ipv4()."]
    #[doc = " @param type type of ICMP packet (should be ICMP_REDIRECT)"]
    #[doc = " @param code code of ICMP packet (should be one of the four redirect codes)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param gateway"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv4_redirect(
        type_: u8,
        code: u8,
        sum: u16,
        gateway: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) time"]
    #[doc = " exceeded header.  The IP header that caused the error message should be"]
    #[doc = " built by a previous call to libnet_build_ipv4()."]
    #[doc = " @param type type of ICMP packet (should be ICMP_TIMXCEED)"]
    #[doc = " @param code code of ICMP packet (ICMP_TIMXCEED_INTRANS / ICMP_TIMXCEED_REASS)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv4_timeexceed(
        type_: u8,
        code: u8,
        sum: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP)"]
    #[doc = " timestamp request/reply header."]
    #[doc = " @param type type of ICMP packet (should be ICMP_TSTAMP or ICMP_TSTAMPREPLY)"]
    #[doc = " @param code code of ICMP packet (should be 0)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param id identification number"]
    #[doc = " @param seq sequence number"]
    #[doc = " @param otime originate timestamp"]
    #[doc = " @param rtime receive timestamp"]
    #[doc = " @param ttime transmit timestamp"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv4_timestamp(
        type_: u8,
        code: u8,
        sum: u16,
        id: u16,
        seq: u16,
        otime: u32,
        rtime: u32,
        ttime: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 6 RFC 4443 Internet Control Message Protocol (ICMP)"]
    #[doc = " echo or echo reply header."]
    #[doc = " @param type type of ICMP packet (should be ICMP6_ECHO_REQUEST or ICMP6_ECHO_REPLY)"]
    #[doc = " @param code code of ICMP packet (should be zero)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param id echo id number"]
    #[doc = " @param seq echo sequence number"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv6_echo(
        type_: u8,
        code: u8,
        sum: u16,
        id: u16,
        seq: u16,
        payload: *mut u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 6 RFC 4443 Internet Control Message Protocol (ICMP)"]
    #[doc = " unreachable header. The IP header that caused the error message should be"]
    #[doc = " built by a previous call to libnet_build_ipv6()."]
    #[doc = " @param type type of ICMP packet (should be ICMP6_DST_UNREACH)"]
    #[doc = " @param code code of ICMP packet (should be one of the 5 ICMP6_DST_UNREACH_* codes)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv6_unreach(
        type_: u8,
        code: u8,
        sum: u16,
        payload: *mut u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 6 RFC 2461 Internet Control Message Protocol (ICMP)"]
    #[doc = " NDP neighbour solicitation header. Could be used with"]
    #[doc = " libnet_build_icmpv6_ndp_opt() and ICMPV6_NDP_OPT_SLLA."]
    #[doc = " @param type type of ICMP packet (should be ND_NEIGHBOR_SOLICIT)"]
    #[doc = " @param code code of ICMP packet (should be zero)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param target target ipv6 address"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv6_ndp_nsol(
        type_: u8,
        code: u8,
        sum: u16,
        target: libnet_in6_addr,
        payload: *mut u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IP version 6 RFC 2461 Internet Control Message Protocol (ICMP)"]
    #[doc = " NDP neighbour advertisement header. Could be used with"]
    #[doc = " libnet_build_icmpv6_ndp_opt() and ND_OPT_TARGET_LINKADDR."]
    #[doc = " @param type type of ICMP packet (should be ND_NEIGHBOR_ADVERT)"]
    #[doc = " @param code code of ICMP packet (should be zero)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param flags should be a bitwise or of any applicable ND_NA_FLAG_* flags"]
    #[doc = " @param target target ipv6 address"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv6_ndp_nadv(
        type_: u8,
        code: u8,
        sum: u16,
        flags: u32,
        target: libnet_in6_addr,
        payload: *mut u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds ICMPv6 NDP options."]
    #[doc = " @param type one of ND_OPT_* types"]
    #[doc = " @param option option data"]
    #[doc = " @param option_s size of option data (will be padded out to an 8-byte boundary)"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_icmpv6_ndp_opt(
        type_: u8,
        option: *mut u8,
        option_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 1112 Internet Group Memebership Protocol (IGMP) header."]
    #[doc = " @param type packet type"]
    #[doc = " @param reserved (should be 0 for IGMPv1)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param ip IPv4 address (in standard/network byte order)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    #[doc = ""]
    #[doc = " @note \'reserved\' was previously called \'code\', which it is not, in any IGMP version."]
    pub fn libnet_build_igmp(
        type_: u8,
        reserved: u8,
        sum: u16,
        ip: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a version 4 RFC 791 Internet Protocol (IP) header."]
    #[doc = ""]
    #[doc = " @param ip_len total length of the IP packet including all subsequent data (subsequent"]
    #[doc = "   data includes any IP options and IP options padding)"]
    #[doc = " @param tos type of service bits"]
    #[doc = " @param id IP identification number"]
    #[doc = " @param frag fragmentation bits and offset"]
    #[doc = " @param ttl time to live in the network"]
    #[doc = " @param prot upper layer protocol"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param src source IPv4 address (little endian)"]
    #[doc = " @param dst destination IPv4 address (little endian)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipv4(
        ip_len: u16,
        tos: u8,
        id: u16,
        frag: u16,
        ttl: u8,
        prot: u8,
        sum: u16,
        src: u32,
        dst: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an version 4 Internet Protocol (IP) options header. The function"]
    #[doc = " expects options to be a valid IP options string of size options_s, no larger"]
    #[doc = " than 40 bytes (the maximum size of an options string)."]
    #[doc = ""]
    #[doc = " When building a chain, the options must be built, then the IPv4 header."]
    #[doc = ""]
    #[doc = " When updating a chain, if the block following the options is an IPv4 header,"]
    #[doc = " it\'s total length and header length will be updated if the options block"]
    #[doc = " size changes."]
    #[doc = ""]
    #[doc = " @param options byte string of IP options (it will be padded up to be an integral"]
    #[doc = "   multiple of 32-bit words)."]
    #[doc = " @param options_s length of options string"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipv4_options(
        options: *const u8,
        options_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Autobuilds a version 4 Internet Protocol (IP) header. The function is useful"]
    #[doc = " to build an IP header quickly when you do not need a granular level of"]
    #[doc = " control. The function takes the same len, prot, and dst arguments as"]
    #[doc = " libnet_build_ipv4(). The function does not accept a ptag argument, but it"]
    #[doc = " does return a ptag. In other words, you can use it to build a new IP header"]
    #[doc = " but not to modify an existing one."]
    #[doc = " @param len total length of the IP packet including all subsequent data"]
    #[doc = " @param prot upper layer protocol"]
    #[doc = " @param dst destination IPv4 address (little endian)"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_autobuild_ipv4(len: u16, prot: u8, dst: u32, l: *mut libnet_t) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a version 6 RFC 2460 Internet Protocol (IP) header."]
    #[doc = " @param tc traffic class"]
    #[doc = " @param fl flow label"]
    #[doc = " @param len total length of the IP packet"]
    #[doc = " @param nh next header"]
    #[doc = " @param hl hop limit"]
    #[doc = " @param src source IPv6 address"]
    #[doc = " @param dst destination IPv6 address"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipv6(
        tc: u8,
        fl: u32,
        len: u16,
        nh: u8,
        hl: u8,
        src: libnet_in6_addr,
        dst: libnet_in6_addr,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a version 6 RFC 2460 Internet Protocol (IP) fragmentation header."]
    #[doc = " @param nh next header"]
    #[doc = " @param reserved unused value... OR IS IT!"]
    #[doc = " @param frag fragmentation bits (ala ipv4)"]
    #[doc = " @param id packet identification"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipv6_frag(
        nh: u8,
        reserved: u8,
        frag: u16,
        id: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a version 6 RFC 2460 Internet Protocol (IP) routing header. This"]
    #[doc = " function is special in that it uses the payload interface to include the"]
    #[doc = " \"type-specific data\"; that is the routing information. Most often this will"]
    #[doc = " be a number of 128-bit IPv6 addresses. The application programmer will build"]
    #[doc = " a byte string of IPv6 address and pass them to the function using the"]
    #[doc = " payload interface."]
    #[doc = " @param nh next header"]
    #[doc = " @param len length of the header in 8-byte octets not including the first 8 octets"]
    #[doc = " @param rtype routing header type"]
    #[doc = " @param segments number of routing segments that follow"]
    #[doc = " @param payload optional payload of routing information"]
    #[doc = " @param payload_s payload length"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipv6_routing(
        nh: u8,
        len: u8,
        rtype: u8,
        segments: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a version 6 RFC 2460 Internet Protocol (IP) destination options"]
    #[doc = " header. This function is special in that it uses the payload interface to"]
    #[doc = " include the options data. The application programmer will build an IPv6"]
    #[doc = " options byte string and pass it to the function using the payload interface."]
    #[doc = " @param nh next header"]
    #[doc = " @param len length of the header in 8-byte octets not including the first 8 octets"]
    #[doc = " @param payload options payload"]
    #[doc = " @param payload_s payload length"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipv6_destopts(
        nh: u8,
        len: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a version 6 RFC 2460 Internet Protocol (IP) hop by hop options"]
    #[doc = " header. This function is special in that it uses the payload interface to"]
    #[doc = " include the options data. The application programmer will build an IPv6"]
    #[doc = " hop by hop options byte string and pass it to the function using the payload"]
    #[doc = " interface."]
    #[doc = " @param nh next header"]
    #[doc = " @param len length of the header in 8-byte octets not including the first 8 octets"]
    #[doc = " @param payload options payload"]
    #[doc = " @param payload_s payload length"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipv6_hbhopts(
        nh: u8,
        len: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Autobuilds a version 6 RFC 2460 Internet Protocol (IP) header. The function"]
    #[doc = " is useful to build an IP header quickly when you do not need a granular"]
    #[doc = " level of control. The function takes the same len, nh, and dst arguments"]
    #[doc = " as libnet_build_ipv4(). The function does not accept a ptag argument, but it"]
    #[doc = " does return a ptag. In other words, you can use it to build a new IP header"]
    #[doc = " but not to modify an existing one."]
    #[doc = " This function requires libnet_get_ipaddr6(), which is not yet implemented"]
    #[doc = " for Win32 platforms."]
    #[doc = " @param len length"]
    #[doc = " @param nh next header"]
    #[doc = " @param dst destination IPv6 address"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_autobuild_ipv6(
        len: u16,
        nh: u8,
        dst: libnet_in6_addr,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a Cisco Inter-Switch Link (ISL) header."]
    #[doc = " @param dhost destination address (should be 01:00:0c:00:00)"]
    #[doc = " @param type type of frame"]
    #[doc = " @param user user defined data"]
    #[doc = " @param shost source mac address"]
    #[doc = " @param len total length of the encapuslated packet less 18 bytes"]
    #[doc = " @param snap SNAP information (0xaaaa03 + vendor code)"]
    #[doc = " @param vid 15 bit VLAN ID, 1 bit BPDU or CDP indicator"]
    #[doc = " @param portindex port index"]
    #[doc = " @param reserved used for FDDI and token ring"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_isl(
        dhost: *mut u8,
        type_: u8,
        user: u8,
        shost: *mut u8,
        len: u16,
        snap: *const u8,
        vid: u16,
        portindex: u16,
        reserved: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an Internet Protocol Security Encapsulating Security Payload header."]
    #[doc = " @param spi security parameter index"]
    #[doc = " @param seq ESP sequence number"]
    #[doc = " @param iv initialization vector"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipsec_esp_hdr(
        spi: u32,
        seq: u32,
        iv: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an Internet Protocol Security Encapsulating Security Payload footer."]
    #[doc = " @param len padding length"]
    #[doc = " @param nh next header"]
    #[doc = " @param auth authentication data"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipsec_esp_ftr(
        len: u8,
        nh: u8,
        auth: *mut i8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an Internet Protocol Security Authentication header."]
    #[doc = " @param nh next header"]
    #[doc = " @param len payload length"]
    #[doc = " @param res reserved"]
    #[doc = " @param spi security parameter index"]
    #[doc = " @param seq sequence number"]
    #[doc = " @param auth authentication data"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ipsec_ah(
        nh: u8,
        len: u8,
        res: u16,
        spi: u32,
        seq: u32,
        auth: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 1035 version 4 DNS header. Additional DNS payload information"]
    #[doc = " should be specified using the payload interface."]
    #[doc = " @param h_len"]
    #[doc = " @param id DNS packet id"]
    #[doc = " @param flags control flags"]
    #[doc = " @param num_q number of questions"]
    #[doc = " @param num_anws_rr number of answer resource records"]
    #[doc = " @param num_auth_rr number of authority resource records"]
    #[doc = " @param num_addi_rr number of additional resource records"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_dnsv4(
        h_len: u16,
        id: u16,
        flags: u16,
        num_q: u16,
        num_anws_rr: u16,
        num_auth_rr: u16,
        num_addi_rr: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a Routing Information Protocol header (RFCs 1058 and 2453)."]
    #[doc = " @param cmd command"]
    #[doc = " @param version protocol version"]
    #[doc = " @param rd version one: 0, version two: routing domain"]
    #[doc = " @param af address family"]
    #[doc = " @param rt version one: 0, version two: route tag"]
    #[doc = " @param addr IPv4 address"]
    #[doc = " @param mask version one: 0, version two: subnet mask"]
    #[doc = " @param next_hop version one: 0, version two: next hop address"]
    #[doc = " @param metric routing metric"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_rip(
        cmd: u8,
        version: u8,
        rd: u16,
        af: u16,
        rt: u16,
        addr: u32,
        mask: u32,
        next_hop: u32,
        metric: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an Remote Procedure Call (Version 2) Call message header as"]
    #[doc = " specified in RFC 1831. This builder provides the option for"]
    #[doc = " specifying the record marking which is required when used with"]
    #[doc = " streaming protocols (TCP)."]
    #[doc = " @param rm record marking indicating the position in a stream, 0 otherwise"]
    #[doc = " @param xid transaction identifier used to link calls and replies"]
    #[doc = " @param prog_num remote program specification typically between 0 - 1fffffff"]
    #[doc = " @param prog_vers remote program version specification"]
    #[doc = " @param procedure procedure to be performed by remote program"]
    #[doc = " @param cflavor authentication credential type"]
    #[doc = " @param clength credential length (should be 0)"]
    #[doc = " @param cdata opaque credential data (currently unused)"]
    #[doc = " @param vflavor authentication verifier type"]
    #[doc = " @param vlength verifier length (should be 0)"]
    #[doc = " @param vdata opaque verifier data (currently unused)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_rpc_call(
        rm: u32,
        xid: u32,
        prog_num: u32,
        prog_vers: u32,
        procedure: u32,
        cflavor: u32,
        clength: u32,
        cdata: *mut u8,
        vflavor: u32,
        vlength: u32,
        vdata: *const u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IEEE 802.1d Spanning Tree Protocol (STP) configuration header."]
    #[doc = " STP frames are usually encapsulated inside of an 802.2 + 802.3 frame"]
    #[doc = " combination."]
    #[doc = " @param id protocol id"]
    #[doc = " @param version protocol version"]
    #[doc = " @param bpdu_type bridge protocol data unit type"]
    #[doc = " @param flags flags"]
    #[doc = " @param root_id root id"]
    #[doc = " @param root_pc root path cost"]
    #[doc = " @param bridge_id bridge id"]
    #[doc = " @param port_id port id"]
    #[doc = " @param message_age message age"]
    #[doc = " @param max_age max age"]
    #[doc = " @param hello_time hello time"]
    #[doc = " @param f_delay forward delay"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_stp_conf(
        id: u16,
        version: u8,
        bpdu_type: u8,
        flags: u8,
        root_id: *const u8,
        root_pc: u32,
        bridge_id: *const u8,
        port_id: u16,
        message_age: u16,
        max_age: u16,
        hello_time: u16,
        f_delay: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an IEEE 802.1d Spanning Tree Protocol (STP) topology change"]
    #[doc = " notification header. STP frames are usually encapsulated inside of an"]
    #[doc = " 802.2 + 802.3 frame combination."]
    #[doc = " @param id protocol id"]
    #[doc = " @param version protocol version"]
    #[doc = " @param bpdu_type bridge protocol data unit type"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_stp_tcn(
        id: u16,
        version: u8,
        bpdu_type: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a token ring header."]
    #[doc = " @param ac access control"]
    #[doc = " @param fc frame control"]
    #[doc = " @param dst destination address"]
    #[doc = " @param src source address"]
    #[doc = " @param dsap destination service access point"]
    #[doc = " @param ssap source service access point"]
    #[doc = " @param cf control field"]
    #[doc = " @param oui Organizationally Unique Identifier"]
    #[doc = " @param type upper layer protocol type"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_token_ring(
        ac: u8,
        fc: u8,
        dst: *const u8,
        src: *const u8,
        dsap: u8,
        ssap: u8,
        cf: u8,
        oui: *const u8,
        type_: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Auto-builds a token ring header."]
    #[doc = " @param ac access control"]
    #[doc = " @param fc frame control"]
    #[doc = " @param dst destination address"]
    #[doc = " @param dsap destination service access point"]
    #[doc = " @param ssap source service access point"]
    #[doc = " @param cf control field"]
    #[doc = " @param oui Organizationally Unique Identifier"]
    #[doc = " @param type upper layer protocol type"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_autobuild_token_ring(
        ac: u8,
        fc: u8,
        dst: *const u8,
        dsap: u8,
        ssap: u8,
        cf: u8,
        oui: *const u8,
        type_: u16,
        l: *mut libnet_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 2338 Virtual Router Redundacy Protool (VRRP) header. Use the"]
    #[doc = " payload interface to specify address and autthentication information. To"]
    #[doc = " build a \"legal\" packet, the destination IPv4 address should be the multicast  * address 224.0.0.18, the IP TTL should be set to 255, and the IP protocol"]
    #[doc = " should be set to 112."]
    #[doc = " @param version VRRP version (should be 2)"]
    #[doc = " @param type VRRP packet type (should be 1 -- ADVERTISEMENT)"]
    #[doc = " @param vrouter_id virtual router identification"]
    #[doc = " @param priority priority (higher numbers indicate higher priority)"]
    #[doc = " @param ip_count number of IPv4 addresses contained in this advertisement"]
    #[doc = " @param auth_type type of authentication (0, 1, 2 -- see RFC)"]
    #[doc = " @param advert_int interval between advertisements"]
    #[doc = " @param sum checksum (0 for libnet to autofill)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_vrrp(
        version: u8,
        type_: u8,
        vrouter_id: u8,
        priority: u8,
        ip_count: u8,
        auth_type: u8,
        advert_int: u8,
        sum: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 3032 Multi-Protocol Label Switching (MPLS) header."]
    #[doc = " @param label 20-bit label value"]
    #[doc = " @param experimental 3-bit reserved field"]
    #[doc = " @param bos 1-bit bottom of stack identifier"]
    #[doc = " @param ttl time to live"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_mpls(
        label: u32,
        experimental: u8,
        bos: u8,
        ttl: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 958 Network Time Protocol (NTP) header."]
    #[doc = " @param leap_indicator the leap indicator"]
    #[doc = " @param version NTP protocol version"]
    #[doc = " @param mode NTP mode"]
    #[doc = " @param stratum stratum"]
    #[doc = " @param poll polling interval"]
    #[doc = " @param precision precision"]
    #[doc = " @param delay_int delay interval"]
    #[doc = " @param delay_frac delay fraction"]
    #[doc = " @param dispersion_int dispersion interval"]
    #[doc = " @param dispersion_frac dispersion fraction"]
    #[doc = " @param reference_id reference id"]
    #[doc = " @param ref_ts_int reference timestamp integer"]
    #[doc = " @param ref_ts_frac reference timestamp fraction"]
    #[doc = " @param orig_ts_int original timestamp integer"]
    #[doc = " @param orig_ts_frac original timestamp fraction"]
    #[doc = " @param rec_ts_int receiver timestamp integer"]
    #[doc = " @param rec_ts_frac reciever timestamp fraction"]
    #[doc = " @param xmt_ts_int transmit timestamp integer"]
    #[doc = " @param xmt_ts_frac transmit timestamp integer"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ntp(
        leap_indicator: u8,
        version: u8,
        mode: u8,
        stratum: u8,
        poll: u8,
        precision: u8,
        delay_int: u16,
        delay_frac: u16,
        dispersion_int: u16,
        dispersion_frac: u16,
        reference_id: u32,
        ref_ts_int: u32,
        ref_ts_frac: u32,
        orig_ts_int: u32,
        orig_ts_frac: u32,
        rec_ts_int: u32,
        rec_ts_frac: u32,
        xmt_ts_int: u32,
        xmt_ts_frac: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param len"]
    #[doc = " @param type"]
    #[doc = " @param rtr_id"]
    #[doc = " @param area_id"]
    #[doc = " @param sum"]
    #[doc = " @param autype"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2(
        len: u16,
        type_: u8,
        rtr_id: u32,
        area_id: u32,
        sum: u16,
        autype: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param netmask"]
    #[doc = " @param interval"]
    #[doc = " @param opts"]
    #[doc = " @param priority"]
    #[doc = " @param dead_int"]
    #[doc = " @param des_rtr"]
    #[doc = " @param bkup_rtr"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_hello(
        netmask: u32,
        interval: u16,
        opts: u8,
        priority: u8,
        dead_int: u32,
        des_rtr: u32,
        bkup_rtr: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param netmask"]
    #[doc = " @param interval"]
    #[doc = " @param opts"]
    #[doc = " @param priority"]
    #[doc = " @param dead_int"]
    #[doc = " @param des_rtr"]
    #[doc = " @param bkup_rtr"]
    #[doc = " @param neighbor"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_hello_neighbor(
        netmask: u32,
        interval: u16,
        opts: u8,
        priority: u8,
        dead_int: u32,
        des_rtr: u32,
        bkup_rtr: u32,
        neighbor: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param dgram_len"]
    #[doc = " @param opts"]
    #[doc = " @param type"]
    #[doc = " @param seqnum"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_dbd(
        dgram_len: u16,
        opts: u8,
        type_: u8,
        seqnum: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param type"]
    #[doc = " @param lsid"]
    #[doc = " @param advrtr"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_lsr(
        type_: u32,
        lsid: u32,
        advrtr: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param num"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_lsu(
        num: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param age"]
    #[doc = " @param opts"]
    #[doc = " @param type"]
    #[doc = " @param lsid"]
    #[doc = " @param advrtr"]
    #[doc = " @param seqnum"]
    #[doc = " @param sum"]
    #[doc = " @param len"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_lsa(
        age: u16,
        opts: u8,
        type_: u8,
        lsid: u32,
        advrtr: u32,
        seqnum: u32,
        sum: u16,
        len: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param flags"]
    #[doc = " @param num"]
    #[doc = " @param id"]
    #[doc = " @param data"]
    #[doc = " @param type"]
    #[doc = " @param tos"]
    #[doc = " @param metric"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_lsa_rtr(
        flags: u16,
        num: u16,
        id: u32,
        data: u32,
        type_: u8,
        tos: u8,
        metric: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param nmask"]
    #[doc = " @param rtrid"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_lsa_net(
        nmask: u32,
        rtrid: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param nmask"]
    #[doc = " @param metric"]
    #[doc = " @param tos"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_lsa_sum(
        nmask: u32,
        metric: u32,
        tos: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param nmask"]
    #[doc = " @param metric"]
    #[doc = " @param fwdaddr"]
    #[doc = " @param tag"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_ospfv2_lsa_as(
        nmask: u32,
        metric: u32,
        fwdaddr: u32,
        tag: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a generic libnet protocol header. This is useful for including an"]
    #[doc = " optional payload to a packet that might need to change repeatedly inside"]
    #[doc = " of a loop. This won\'t work for TCP or IP payload, they have special types"]
    #[doc = " (this is probably a bug)."]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_data(
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param opcode"]
    #[doc = " @param htype"]
    #[doc = " @param hlen"]
    #[doc = " @param hopcount"]
    #[doc = " @param xid"]
    #[doc = " @param secs"]
    #[doc = " @param flags"]
    #[doc = " @param cip"]
    #[doc = " @param yip"]
    #[doc = " @param sip"]
    #[doc = " @param gip"]
    #[doc = " @param chaddr client hardware address, length is hlen"]
    #[doc = " @param sname server host name, a null terminated string"]
    #[doc = " @param file boot file name, a null terminated string"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_dhcpv4(
        opcode: u8,
        htype: u8,
        hlen: u8,
        hopcount: u8,
        xid: u32,
        secs: u16,
        flags: u16,
        cip: u32,
        yip: u32,
        sip: u32,
        gip: u32,
        chaddr: *const u8,
        sname: *const libc::c_char,
        file: *const libc::c_char,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param opcode"]
    #[doc = " @param htype"]
    #[doc = " @param hlen"]
    #[doc = " @param hopcount"]
    #[doc = " @param xid"]
    #[doc = " @param secs"]
    #[doc = " @param flags"]
    #[doc = " @param cip"]
    #[doc = " @param yip"]
    #[doc = " @param sip"]
    #[doc = " @param gip"]
    #[doc = " @param chaddr client hardware address, length is hlen"]
    #[doc = " @param sname server host name, a null terminated string"]
    #[doc = " @param file boot file name, a null terminated string"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_bootpv4(
        opcode: u8,
        htype: u8,
        hlen: u8,
        hopcount: u8,
        xid: u32,
        secs: u16,
        flags: u16,
        cip: u32,
        yip: u32,
        sip: u32,
        gip: u32,
        chaddr: *const u8,
        sname: *const libc::c_char,
        file: *const libc::c_char,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param fv see libnet_build_gre()."]
    #[doc = " @return size"]
    #[doc = " @see libnet_build_gre()."]
    pub fn libnet_getgre_length(fv: u16) -> u32;
}
extern "C" {
    #[doc = " Generic Routing Encapsulation (GRE - RFC 1701) is used to encapsulate any"]
    #[doc = " protocol. Hence, the IP part of the packet is usually referred as \"delivery"]
    #[doc = " header\". It is then followed by the GRE header and finally the encapsulated"]
    #[doc = " packet (IP or whatever)."]
    #[doc = " As GRE is very modular, the first GRE header describes the structure of the"]
    #[doc = " header, using bits and flag to specify which fields will be present in the"]
    #[doc = " header."]
    #[doc = " @param fv the 16 0 to 7: which fields are included in the header (checksum,"]
    #[doc = "   seq. number, key, ...), bits 8 to 12: flag, bits 13 to 15: version."]
    #[doc = " @param type which protocol is encapsulated (PPP, IP, ...)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)."]
    #[doc = " @param offset byte offset from the start of the routing field to the first byte of the SRE"]
    #[doc = " @param key inserted by the encapsulator to authenticate the source"]
    #[doc = " @param seq sequence number used by the receiver to sort the packets"]
    #[doc = " @param len size of the GRE packet"]
    #[doc = " @param payload"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_gre(
        fv: u16,
        type_: u16,
        sum: u16,
        offset: u16,
        key: u32,
        seq: u32,
        len: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Generic Routing Encapsulation (GRE - RFC 1701) is used to encapsulate any"]
    #[doc = " protocol. Hence, the IP part of the packet is usually referred as \"delivery"]
    #[doc = " header\". It is then followed by the GRE header and finally the encapsulated"]
    #[doc = " packet (IP or whatever)."]
    #[doc = " As GRE is very modular, the first GRE header describes the structure of the"]
    #[doc = " header, using bits and flag to specify which fields will be present in the"]
    #[doc = " header."]
    #[doc = " @param fv the 16 0 to 7: which fields are included in the header (checksum, seq. number, key, ...), bits 8 to 12: flag, bits 13 to 15: version."]
    #[doc = " @param type which protocol is encapsulated (PPP, IP, ...)"]
    #[doc = " @param sum checksum (0 for libnet to autofill)."]
    #[doc = " @param offset byte offset from the start of the routing field to the first byte of the SRE"]
    #[doc = " @param key inserted by the encapsulator to authenticate the source"]
    #[doc = " @param seq sequence number used by the receiver to sort the packets"]
    #[doc = " @param len size of the GRE packet"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_egre(
        fv: u16,
        type_: u16,
        sum: u16,
        offset: u16,
        key: u32,
        seq: u32,
        len: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param af"]
    #[doc = " @param offset"]
    #[doc = " @param length"]
    #[doc = " @param routing"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_gre_sre(
        af: u16,
        offset: u8,
        length: u8,
        routing: *mut u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_gre_last_sre(l: *mut libnet_t, ptag: libnet_ptag_t) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) header. The primary"]
    #[doc = " function of a BGP speaking system is to exchange network reachability"]
    #[doc = " information with other BGP systems. This network reachability information"]
    #[doc = " includes information on the list of  Autonomous Systems (ASs) that"]
    #[doc = " reachability information traverses.  This information is sufficient to"]
    #[doc = " construct a graph of AS connectivity from which routing loops may be pruned"]
    #[doc = " and some policy decisions at the AS level may be enforced."]
    #[doc = " This function builds the base BGP header which is used as a preamble before"]
    #[doc = " any other BGP header. For example, a BGP KEEPALIVE message may be built with"]
    #[doc = " only this function, while an error notification requires a subsequent call"]
    #[doc = " to libnet_build_bgp4_notification."]
    #[doc = " @param marker a value the receiver can predict (if the message type is not BGP OPEN, or no authentication is used, these 16 bytes are normally set as all ones)"]
    #[doc = " @param len total length of the BGP message, including the header"]
    #[doc = " @param type type code of the message (OPEN, UPDATE, NOTIFICATION or KEEPALIVE)"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_bgp4_header(
        marker: *mut u8,
        len: u16,
        type_: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) OPEN header. This is"]
    #[doc = " the first message sent by each side of a BGP connection. The optional"]
    #[doc = " parameters options should be constructed using the payload interface (see"]
    #[doc = " RFC 1771 for the options structures)."]
    #[doc = " @param version protocol version (should be set to 4)"]
    #[doc = " @param src_as Autonomous System of the sender"]
    #[doc = " @param hold_time used to compute the maximum allowed time between the receipt of KEEPALIVE, and/or UPDATE messages by the sender"]
    #[doc = " @param bgp_id BGP identifier of the sender"]
    #[doc = " @param opt_len total length of the  optional parameters field in bytes"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_bgp4_open(
        version: u8,
        src_as: u16,
        hold_time: u16,
        bgp_id: u32,
        opt_len: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) update header. Update"]
    #[doc = " messages are used to transfer routing information between BGP peers."]
    #[doc = " @param unfeasible_rt_len indicates the length of the (next) \"withdrawn routes\" field in bytes"]
    #[doc = " @param withdrawn_rt list of IP addresses prefixes for the routes that are being withdrawn; each IP address prefix is built as a 2-tuple <length (1 byte), prefix (variable)>"]
    #[doc = " @param total_path_attr_len indicates the length of the (next) \"path attributes\" field in bytes"]
    #[doc = " @param path_attributes each attribute is a 3-tuple <type (2 bytes), length, value>"]
    #[doc = " @param info_len indicates the length of the (next) \"network layer reachability information\" field in bytes (needed for internal memory size calculation)"]
    #[doc = " @param reachability_info 2-tuples <length (1 byte), prefix (variable)>."]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_bgp4_update(
        unfeasible_rt_len: u16,
        withdrawn_rt: *const u8,
        total_path_attr_len: u16,
        path_attributes: *const u8,
        info_len: u16,
        reachability_info: *mut u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) notification header."]
    #[doc = " A NOTIFICATION message is sent when an error condition is detected. Specific"]
    #[doc = " error information may be passed through the payload interface."]
    #[doc = " @param err_code type of notification"]
    #[doc = " @param err_subcode more specific information about the reported error."]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_bgp4_notification(
        err_code: u8,
        err_subcode: u8,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a Sebek header. The Sebek protocol was designed by the Honeynet"]
    #[doc = " Project as a transport mechanism for post-intrusion forensic data. More"]
    #[doc = " information may be found here: http://www.honeynet.org/papers/sebek.pdf."]
    #[doc = " @param magic identify packets that should be hidden"]
    #[doc = " @param version protocol version, currently 1"]
    #[doc = " @param type type of record (read data is type 0, write data is type 1)"]
    #[doc = " @param counter PDU counter used to identify when packet are lost"]
    #[doc = " @param time_sec seconds since EPOCH according to the honeypot"]
    #[doc = " @param time_usec residual microseconds"]
    #[doc = " @param pid PID"]
    #[doc = " @param uid UID"]
    #[doc = " @param fd FD"]
    #[doc = " @param cmd 12 first characters of the command"]
    #[doc = " @param length length in bytes of the PDU\'s body"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_sebek(
        magic: u32,
        version: u16,
        type_: u16,
        counter: u32,
        time_sec: u32,
        time_usec: u32,
        pid: u32,
        uid: u32,
        fd: u32,
        cmd: *mut u8,
        length: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a HSRP header. HSRP is a Cisco propietary protocol defined in"]
    #[doc = " RFC 2281"]
    #[doc = " @param version version of the HSRP messages"]
    #[doc = " @param opcode type of message"]
    #[doc = " @param state current state of the router"]
    #[doc = " @param hello_time period in seconds between hello messages"]
    #[doc = " @param hold_time seconds that the current hello message is valid"]
    #[doc = " @param priority priority for the election proccess"]
    #[doc = " @param group standby group"]
    #[doc = " @param reserved reserved field"]
    #[doc = " @param authdata password"]
    #[doc = " @param virtual_ip virtual ip address"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_hsrp(
        version: u8,
        opcode: u8,
        state: u8,
        hello_time: u8,
        hold_time: u8,
        priority: u8,
        group: u8,
        reserved: u8,
        authdata: *mut u8,
        virtual_ip: u32,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Builds a link layer header for an initialized l. The function"]
    #[doc = " determines the proper link layer header format from how l was initialized."]
    #[doc = " The function current supports Ethernet and Token Ring link layers."]
    #[doc = " @param dst the destination MAC address"]
    #[doc = " @param src the source MAC address"]
    #[doc = " @param oui Organizationally Unique Identifier (unused for Ethernet)"]
    #[doc = " @param type the upper layer protocol type"]
    #[doc = " @param payload optional payload or NULL"]
    #[doc = " @param payload_s payload length or 0"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag protocol tag to modify an existing header, 0 to build a new one"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_build_link(
        dst: *const u8,
        src: *const u8,
        oui: *const u8,
        type_: u16,
        payload: *const u8,
        payload_s: u32,
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Automatically builds a link layer header for an initialized l. The function"]
    #[doc = " determines the proper link layer header format from how l was initialized."]
    #[doc = " The function current supports Ethernet and Token Ring link layers."]
    #[doc = " @param dst the destination MAC address"]
    #[doc = " @param oui Organizationally Unique Identifier (unused for Ethernet)"]
    #[doc = " @param type the upper layer protocol type"]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return protocol tag value on success"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_autobuild_link(
        dst: *const u8,
        oui: *const u8,
        type_: u16,
        l: *mut libnet_t,
    ) -> libnet_ptag_t;
}
extern "C" {
    #[doc = " Writes a prebuilt packet to the network. The function assumes that l was"]
    #[doc = " previously initialized (via a call to libnet_init()) and that a"]
    #[doc = " previously constructed packet has been built inside this context (via one or"]
    #[doc = " more calls to the libnet_build* family of functions) and is ready to go."]
    #[doc = " Depending on how libnet was initialized, the function will write the packet"]
    #[doc = " to the wire either via the raw or link layer interface. The function will"]
    #[doc = " also bump up the internal libnet stat counters which are retrievable via"]
    #[doc = " libnet_stats()."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return the number of bytes written"]
    #[doc = " @retval -1 on error"]
    pub fn libnet_write(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the IP address for the device libnet was initialized with. If"]
    #[doc = " libnet was initialized without a device (in raw socket mode) the function"]
    #[doc = " will attempt to find one. If the function fails and returns -1 a call to"]
    #[doc = " libnet_geterrror() will tell you why."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return a big endian IP address suitable for use in a libnet_build function"]
    #[doc = " @retval -1"]
    pub fn libnet_get_ipaddr4(l: *mut libnet_t) -> u32;
}
extern "C" {
    #[doc = " Returns the IPv6 address for the device libnet was initialized with. If"]
    #[doc = " libnet was initialized without a device (in raw socket mode) the function"]
    #[doc = " will attempt to find one. If the function fails and returns in6addr_error, a"]
    #[doc = " call to libnet_geterrror() will tell you why."]
    #[doc = " This function is not yet implemented for Win32 platforms."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @retval in6addr_error on failure"]
    pub fn libnet_get_ipaddr6(l: *mut libnet_t) -> libnet_in6_addr;
}
extern "C" {
    #[doc = " Returns the MAC address for the device libnet was initialized with. If"]
    #[doc = " libnet was initialized without a device the function will attempt to find"]
    #[doc = " one. If the function fails and returns NULL a call to libnet_geterror() will"]
    #[doc = " tell you why."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return a pointer to the MAC address or NULL"]
    pub fn libnet_get_hwaddr(l: *mut libnet_t) -> *mut libnet_ether_addr;
}
extern "C" {
    #[doc = " Takes a colon separated hexidecimal address (from the command line) and"]
    #[doc = " returns a bytestring suitable for use in a libnet_build function. Note this"]
    #[doc = " function performs an implicit malloc and the return value should be freed"]
    #[doc = " after its use."]
    #[doc = " @param s the string to be parsed"]
    #[doc = " @param len the resulting size of the returned byte string"]
    #[doc = " @return a byte string or NULL on failure"]
    pub fn libnet_hex_aton(s: *const libc::c_char, len: *mut libc::c_int) -> *mut u8;
}
extern "C" {
    #[doc = " Returns the version of libnet."]
    #[doc = " @return the libnet version"]
    pub fn libnet_version() -> *const libc::c_char;
}
extern "C" {
    #[doc = " [Advanced Interface]"]
    #[doc = " Yanks a prebuilt, wire-ready packet from the given libnet context. If"]
    #[doc = " libnet was configured to do so (which it is by default) the packet will have"]
    #[doc = " all checksums written in. This function is part of the advanced interface"]
    #[doc = " and is only available when libnet is initialized in advanced mode. It is"]
    #[doc = " important to note that the function performs an implicit malloc() and a"]
    #[doc = " corresponding call to libnet_adv_free_packet() should be made to free the"]
    #[doc = " memory packet occupies. If the function fails libnet_geterror() can tell you"]
    #[doc = " why."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param packet will contain the wire-ready packet"]
    #[doc = " @param packet_s will contain the packet size"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_adv_cull_packet(
        l: *mut libnet_t,
        packet: *mut *mut u8,
        packet_s: *mut u32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " [Advanced Interface]"]
    #[doc = " Pulls the header from the specified ptag from the given libnet context. This"]
    #[doc = " function is part of the advanced interface and is only available when libnet"]
    #[doc = " is initialized in advanced mode. If the function fails libnet_geterror() can"]
    #[doc = " tell you why."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param ptag the ptag referencing the header to pull"]
    #[doc = " @param header will contain the header"]
    #[doc = " @param header_s will contain the header size"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_adv_cull_header(
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
        header: *mut *mut u8,
        header_s: *mut u32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " [Advanced Interface]"]
    #[doc = " Writes a packet the network at the link layer. This function is useful to"]
    #[doc = " write a packet that has been constructed by hand by the application"]
    #[doc = " programmer or, more commonly, to write a packet that has been returned by"]
    #[doc = " a call to libnet_adv_cull_packet(). This function is part of the advanced"]
    #[doc = " interface and is only available when libnet is initialized in advanced mode."]
    #[doc = " If the function fails libnet_geterror() can tell you why."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param packet a pointer to the packet to inject"]
    #[doc = " @param packet_s the size of the packet"]
    #[doc = " @return the number of bytes written"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_adv_write_link(l: *mut libnet_t, packet: *const u8, packet_s: u32)
        -> libc::c_int;
}
extern "C" {
    #[doc = " [Advanced Interface]"]
    #[doc = " Writes a packet the network at the raw socket layer. This function is useful"]
    #[doc = " to write a packet that has been constructed by hand by the application"]
    #[doc = " programmer or, more commonly, to write a packet that has been returned by"]
    #[doc = " a call to libnet_adv_cull_packet(). This function is part of the advanced"]
    #[doc = " interface and is only available when libnet is initialized in advanced mode."]
    #[doc = " If the function fails libnet_geterror() can tell you why."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param packet a pointer to the packet to inject"]
    #[doc = " @param packet_s the size of the packet"]
    #[doc = " @return the number of bytes written"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_adv_write_raw_ipv4(
        l: *mut libnet_t,
        packet: *const u8,
        packet_s: u32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " [Advanced Interface]"]
    #[doc = " Frees the memory allocated when libnet_adv_cull_packet() is called."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param packet a pointer to the packet to free"]
    pub fn libnet_adv_free_packet(l: *mut libnet_t, packet: *mut u8);
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Adds a new context to the libnet context queue. If no queue exists, this"]
    #[doc = " function will create the queue and add the specified libnet context as the"]
    #[doc = " first entry on the list. The functions checks to ensure niether l nor label"]
    #[doc = " are NULL, and that label doesn\'t refer to an existing context already in the"]
    #[doc = " queue. Additionally, l should refer to a libnet context previously"]
    #[doc = " initialized with a call to libnet_init(). If the context queue in write"]
    #[doc = " locked, this function will fail."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @param label a canonical name given to recognize the new context, no longer than LIBNET_LABEL_SIZE"]
    #[doc = " @retval 1 on success"]
    #[doc = " @retval -1 on failure"]
    pub fn libnet_cq_add(l: *mut libnet_t, label: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Removes a specified context from the libnet context queue by specifying the"]
    #[doc = " libnet context pointer. Note the function will remove the specified context"]
    #[doc = " from the context queue and cleanup internal memory from the queue, it is up"]
    #[doc = " to the application programmer to free the returned libnet context with a"]
    #[doc = " call to libnet_destroy(). Also, as it is not necessary to keep the libnet"]
    #[doc = " context pointer when initially adding it to the context queue, most"]
    #[doc = " application programmers will prefer to refer to entries on the context"]
    #[doc = " queue by canonical name and would use libnet_cq_remove_by_label(). If the"]
    #[doc = " context queue is write locked, this function will fail."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return the pointer to the removed libnet context"]
    #[doc = " @retval NULL on failure"]
    pub fn libnet_cq_remove(l: *mut libnet_t) -> *mut libnet_t;
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Removes a specified context from the libnet context queue by specifying the"]
    #[doc = " canonical name. Note the function will remove the specified context from"]
    #[doc = " the context queue and cleanup internal memory from the queue, it is up to"]
    #[doc = " the application programmer to free the returned libnet context with a call"]
    #[doc = " to libnet_destroy(). If the context queue is write locked, this function"]
    #[doc = " will fail."]
    #[doc = " @param label canonical name of the context to remove"]
    #[doc = " @return the pointer to the removed libnet context"]
    #[doc = " @retval NULL on failure"]
    pub fn libnet_cq_remove_by_label(label: *mut libc::c_char) -> *mut libnet_t;
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Returns the canonical label associated with the context."]
    #[doc = " @param l pointer to a libnet context"]
    #[doc = " @return pointer to the libnet context\'s label"]
    pub fn libnet_cq_getlabel(l: *mut libnet_t) -> *const libc::c_char;
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Locates a libnet context from the queue, indexed by a canonical label."]
    #[doc = " @param label canonical label of the libnet context to retrieve"]
    #[doc = " @return the expected libnet context"]
    #[doc = " @retval NULL on failure"]
    pub fn libnet_cq_find_by_label(label: *mut libc::c_char) -> *mut libnet_t;
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Destroys the entire context queue, calling libnet_destroy() on each"]
    #[doc = " member context."]
    pub fn libnet_cq_destroy();
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Intiailizes the interator interface and set a write lock on the entire"]
    #[doc = " queue. This function is intended to be called just prior to interating"]
    #[doc = " through the entire list of contexts (with the probable intent of inject a"]
    #[doc = " series of packets in rapid succession). This function is often used as"]
    #[doc = " per the following:"]
    #[doc = ""]
    #[doc = "    for (l = libnet_cq_head(); libnet_cq_last(); l = libnet_cq_next())"]
    #[doc = "    {"]
    #[doc = "         ..."]
    #[doc = "    }"]
    #[doc = ""]
    #[doc = " Much of the time, the application programmer will use the iterator as it is"]
    #[doc = " written above; as such, libnet provides a macro to do exactly that,"]
    #[doc = " for_each_context_in_cq(l). Warning: do not call the iterator more than once"]
    #[doc = " in a single loop."]
    #[doc = " @return the head of the context queue"]
    pub fn libnet_cq_head() -> *mut libnet_t;
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Check whether the iterator is at the last context in the queue."]
    #[doc = " @retval 1 if at the end of the context queue"]
    #[doc = " @retval 0 otherwise"]
    pub fn libnet_cq_last() -> libc::c_int;
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Get next context from the context queue."]
    #[doc = " @return the next context from the context queue"]
    pub fn libnet_cq_next() -> *mut libnet_t;
}
extern "C" {
    #[doc = " [Context Queue]"]
    #[doc = " Function returns the number of libnet contexts that are in the queue."]
    #[doc = " @return the number of libnet contexts currently in the queue"]
    pub fn libnet_cq_size() -> u32;
}
extern "C" {
    #[doc = " [Context Queue]"]
    pub fn libnet_cq_end_loop() -> u32;
}
extern "C" {
    #[doc = " [Diagnostic]"]
    #[doc = " Prints the contents of the given context."]
    #[doc = " @param l pointer to a libnet context"]
    pub fn libnet_diag_dump_context(l: *mut libnet_t);
}
extern "C" {
    #[doc = " [Diagnostic]"]
    #[doc = " Prints the contents of every pblock."]
    #[doc = " @param l pointer to a libnet context"]
    pub fn libnet_diag_dump_pblock(l: *mut libnet_t);
}
extern "C" {
    #[doc = " [Diagnostic]"]
    #[doc = " Returns the canonical name of the pblock type."]
    #[doc = " @param type pblock type"]
    #[doc = " @return a string representing the pblock type type"]
    #[doc = " @retval \"unknown\" for an unknown value"]
    pub fn libnet_diag_dump_pblock_type(type_: u8) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " [Diagnostic]"]
    #[doc = " Function prints the contents of the supplied buffer to the supplied"]
    #[doc = " stream pointer. Will swap endianness based disposition of mode variable."]
    #[doc = " Useful to be used in conjunction with the advanced interface and a culled"]
    #[doc = " packet."]
    #[doc = " @param packet the packet to print"]
    #[doc = " @param len length of the packet in bytes"]
    #[doc = " @param swap 1 to swap byte order, 0 to not."]
    #[doc = "   Counter-intuitively, it is necessary to swap in order to see the byte"]
    #[doc = "   order as it is on the wire (this may be a bug)."]
    #[doc = " @param stream a stream pointer to print to"]
    pub fn libnet_diag_dump_hex(packet: *const u8, len: u32, swap: libc::c_int, stream: *mut FILE);
}
extern "C" {
    pub fn libnet_write_raw_ipv4(l: *mut libnet_t, packet: *const u8, size: u32) -> libc::c_int;
}
extern "C" {
    pub fn libnet_write_raw_ipv6(l: *mut libnet_t, packet: *const u8, size: u32) -> libc::c_int;
}
extern "C" {
    pub fn libnet_write_link(l: *mut libnet_t, packet: *const u8, size: u32) -> libc::c_int;
}
extern "C" {
    pub fn libnet_open_raw4(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    pub fn libnet_close_raw4(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    pub fn libnet_open_raw6(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    pub fn libnet_close_raw6(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    pub fn libnet_select_device(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    pub fn libnet_open_link(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    pub fn libnet_close_link(l: *mut libnet_t) -> libc::c_int;
}
extern "C" {
    pub fn libnet_do_checksum(
        l: *mut libnet_t,
        iphdr: *mut u8,
        protocol: libc::c_int,
        h_len: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn libnet_inet_checksum(
        l: *mut libnet_t,
        iphdr: *mut u8,
        protocol: libc::c_int,
        h_len: libc::c_int,
        beg: *const u8,
        end: *const u8,
    ) -> libc::c_int;
}
extern "C" {
    pub fn libnet_compute_crc(buf: *mut u8, len: u32) -> u32;
}
extern "C" {
    pub fn libnet_ip_check(addr: *mut u16, len: libc::c_int) -> u16;
}
extern "C" {
    pub fn libnet_in_cksum(addr: *mut u16, len: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn libnet_pblock_probe(
        l: *mut libnet_t,
        ptag: libnet_ptag_t,
        b_len: u32,
        type_: u8,
    ) -> *mut libnet_pblock_t;
}
extern "C" {
    pub fn libnet_pblock_new(l: *mut libnet_t, b_len: u32) -> *mut libnet_pblock_t;
}
extern "C" {
    pub fn libnet_pblock_swap(
        l: *mut libnet_t,
        ptag1: libnet_ptag_t,
        ptag2: libnet_ptag_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn libnet_pblock_insert_before(
        l: *mut libnet_t,
        ptag1: libnet_ptag_t,
        ptag2: libnet_ptag_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn libnet_pblock_delete(l: *mut libnet_t, p: *mut libnet_pblock_t);
}
extern "C" {
    pub fn libnet_pblock_update(
        l: *mut libnet_t,
        p: *mut libnet_pblock_t,
        h: u32,
        type_: u8,
    ) -> libnet_ptag_t;
}
extern "C" {
    pub fn libnet_pblock_find(l: *mut libnet_t, ptag: libnet_ptag_t) -> *mut libnet_pblock_t;
}
extern "C" {
    pub fn libnet_pblock_append(
        l: *mut libnet_t,
        p: *mut libnet_pblock_t,
        buf: *const libc::c_void,
        len: u32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn libnet_pblock_setflags(p: *mut libnet_pblock_t, flags: u8);
}
extern "C" {
    pub fn libnet_pblock_p2p(type_: u8) -> libc::c_int;
}
extern "C" {
    pub fn libnet_pblock_coalesce(
        l: *mut libnet_t,
        packet: *mut *mut u8,
        size: *mut u32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn libnet_check_iface(l: *mut libnet_t) -> libc::c_int;
}
